// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GRAPHMANIPULATIONMESSAGES_EXECUTIONGRAPHGUI_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_GRAPHMANIPULATIONMESSAGES_EXECUTIONGRAPHGUI_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"

#include "LogicNode_generated.h"
#include "DataTypes_generated.h"
#include "NodeDescription_generated.h"
#include "SocketTypeDescription_generated.h"

namespace executionGraphGUI {
namespace serialization {

struct NodeConstructionInfo;

struct AddNodeRequest;

struct AddNodeResponse;

struct RemoveNodeRequest;

struct NodeConstructionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_CONSTRUCTOR = 8
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ConstructorKV>> *constructor() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ConstructorKV>> *>(VT_CONSTRUCTOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.Verify(type()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_CONSTRUCTOR) &&
           verifier.Verify(constructor()) &&
           verifier.VerifyVectorOfTables(constructor()) &&
           verifier.EndTable();
  }
};

struct NodeConstructionInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(NodeConstructionInfo::VT_TYPE, type);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NodeConstructionInfo::VT_NAME, name);
  }
  void add_constructor(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ConstructorKV>>> constructor) {
    fbb_.AddOffset(NodeConstructionInfo::VT_CONSTRUCTOR, constructor);
  }
  explicit NodeConstructionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeConstructionInfoBuilder &operator=(const NodeConstructionInfoBuilder &);
  flatbuffers::Offset<NodeConstructionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeConstructionInfo>(end);
    fbb_.Required(o, NodeConstructionInfo::VT_TYPE);
    fbb_.Required(o, NodeConstructionInfo::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NodeConstructionInfo> CreateNodeConstructionInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ConstructorKV>>> constructor = 0) {
  NodeConstructionInfoBuilder builder_(_fbb);
  builder_.add_constructor(constructor);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeConstructionInfo> CreateNodeConstructionInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<ConstructorKV>> *constructor = nullptr) {
  return executionGraphGUI::serialization::CreateNodeConstructionInfo(
      _fbb,
      type ? _fbb.CreateString(type) : 0,
      name ? _fbb.CreateString(name) : 0,
      constructor ? _fbb.CreateVector<flatbuffers::Offset<ConstructorKV>>(*constructor) : 0);
}

struct AddNodeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GRAPHID = 4,
    VT_NODE = 6
  };
  const flatbuffers::String *graphId() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPHID);
  }
  const NodeConstructionInfo *node() const {
    return GetPointer<const NodeConstructionInfo *>(VT_NODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRAPHID) &&
           verifier.Verify(graphId()) &&
           VerifyOffsetRequired(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct AddNodeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graphId(flatbuffers::Offset<flatbuffers::String> graphId) {
    fbb_.AddOffset(AddNodeRequest::VT_GRAPHID, graphId);
  }
  void add_node(flatbuffers::Offset<NodeConstructionInfo> node) {
    fbb_.AddOffset(AddNodeRequest::VT_NODE, node);
  }
  explicit AddNodeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNodeRequestBuilder &operator=(const AddNodeRequestBuilder &);
  flatbuffers::Offset<AddNodeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNodeRequest>(end);
    fbb_.Required(o, AddNodeRequest::VT_GRAPHID);
    fbb_.Required(o, AddNodeRequest::VT_NODE);
    return o;
  }
};

inline flatbuffers::Offset<AddNodeRequest> CreateAddNodeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> graphId = 0,
    flatbuffers::Offset<NodeConstructionInfo> node = 0) {
  AddNodeRequestBuilder builder_(_fbb);
  builder_.add_node(node);
  builder_.add_graphId(graphId);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddNodeRequest> CreateAddNodeRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *graphId = nullptr,
    flatbuffers::Offset<NodeConstructionInfo> node = 0) {
  return executionGraphGUI::serialization::CreateAddNodeRequest(
      _fbb,
      graphId ? _fbb.CreateString(graphId) : 0,
      node);
}

struct AddNodeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4
  };
  const NodeDescription *node() const {
    return GetPointer<const NodeDescription *>(VT_NODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct AddNodeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<NodeDescription> node) {
    fbb_.AddOffset(AddNodeResponse::VT_NODE, node);
  }
  explicit AddNodeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNodeResponseBuilder &operator=(const AddNodeResponseBuilder &);
  flatbuffers::Offset<AddNodeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNodeResponse>(end);
    fbb_.Required(o, AddNodeResponse::VT_NODE);
    return o;
  }
};

inline flatbuffers::Offset<AddNodeResponse> CreateAddNodeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NodeDescription> node = 0) {
  AddNodeResponseBuilder builder_(_fbb);
  builder_.add_node(node);
  return builder_.Finish();
}

struct RemoveNodeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GRAPHID = 4,
    VT_ID = 6
  };
  const flatbuffers::String *graphId() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPHID);
  }
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRAPHID) &&
           verifier.Verify(graphId()) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct RemoveNodeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graphId(flatbuffers::Offset<flatbuffers::String> graphId) {
    fbb_.AddOffset(RemoveNodeRequest::VT_GRAPHID, graphId);
  }
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(RemoveNodeRequest::VT_ID, id, 0);
  }
  explicit RemoveNodeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveNodeRequestBuilder &operator=(const RemoveNodeRequestBuilder &);
  flatbuffers::Offset<RemoveNodeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RemoveNodeRequest>(end);
    fbb_.Required(o, RemoveNodeRequest::VT_GRAPHID);
    return o;
  }
};

inline flatbuffers::Offset<RemoveNodeRequest> CreateRemoveNodeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> graphId = 0,
    uint64_t id = 0) {
  RemoveNodeRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_graphId(graphId);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemoveNodeRequest> CreateRemoveNodeRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *graphId = nullptr,
    uint64_t id = 0) {
  return executionGraphGUI::serialization::CreateRemoveNodeRequest(
      _fbb,
      graphId ? _fbb.CreateString(graphId) : 0,
      id);
}

}  // namespace serialization
}  // namespace executionGraphGUI

#endif  // FLATBUFFERS_GENERATED_GRAPHMANIPULATIONMESSAGES_EXECUTIONGRAPHGUI_SERIALIZATION_H_
