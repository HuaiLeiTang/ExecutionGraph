// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXECUTIONGRAPH_EXECUTIONGRAPH_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_EXECUTIONGRAPH_EXECUTIONGRAPH_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

#include "LogicNode_generated.h"
#include "LogicNodeDataUnion_generated.h"
#include "SocketLink_generated.h"

namespace executionGraph {
namespace serialization {

struct NodeProperty;

struct ExecutionGraph;

enum NodeClassification {
  NodeClassification_NormalNode = 0,
  NodeClassification_InputNode = 1,
  NodeClassification_OutputNode = 2,
  NodeClassification_ConstantNode = 3,
  NodeClassification_MIN = NodeClassification_NormalNode,
  NodeClassification_MAX = NodeClassification_ConstantNode
};

inline NodeClassification (&EnumValuesNodeClassification())[4] {
  static NodeClassification values[] = {
    NodeClassification_NormalNode,
    NodeClassification_InputNode,
    NodeClassification_OutputNode,
    NodeClassification_ConstantNode
  };
  return values;
}

inline const char **EnumNamesNodeClassification() {
  static const char *names[] = {
    "NormalNode",
    "InputNode",
    "OutputNode",
    "ConstantNode",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeClassification(NodeClassification e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesNodeClassification()[index];
}

struct NodeProperty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSIFICATION = 4,
    VT_GROUPS = 6
  };
  NodeClassification classification() const {
    return static_cast<NodeClassification>(GetField<int8_t>(VT_CLASSIFICATION, 0));
  }
  const flatbuffers::Vector<uint64_t> *groups() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_GROUPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CLASSIFICATION) &&
           VerifyOffset(verifier, VT_GROUPS) &&
           verifier.Verify(groups()) &&
           verifier.EndTable();
  }
};

struct NodePropertyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classification(NodeClassification classification) {
    fbb_.AddElement<int8_t>(NodeProperty::VT_CLASSIFICATION, static_cast<int8_t>(classification), 0);
  }
  void add_groups(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> groups) {
    fbb_.AddOffset(NodeProperty::VT_GROUPS, groups);
  }
  explicit NodePropertyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodePropertyBuilder &operator=(const NodePropertyBuilder &);
  flatbuffers::Offset<NodeProperty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeProperty>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeProperty> CreateNodeProperty(
    flatbuffers::FlatBufferBuilder &_fbb,
    NodeClassification classification = NodeClassification_NormalNode,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> groups = 0) {
  NodePropertyBuilder builder_(_fbb);
  builder_.add_groups(groups);
  builder_.add_classification(classification);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeProperty> CreateNodePropertyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    NodeClassification classification = NodeClassification_NormalNode,
    const std::vector<uint64_t> *groups = nullptr) {
  return executionGraph::serialization::CreateNodeProperty(
      _fbb,
      classification,
      groups ? _fbb.CreateVector<uint64_t>(*groups) : 0);
}

struct ExecutionGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODES = 4,
    VT_LINKS = 6,
    VT_PROPERTIES = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<LogicNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LogicNode>> *>(VT_NODES);
  }
  const flatbuffers::Vector<const SocketLink *> *links() const {
    return GetPointer<const flatbuffers::Vector<const SocketLink *> *>(VT_LINKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NodeProperty>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeProperty>> *>(VT_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_LINKS) &&
           verifier.Verify(links()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.Verify(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           verifier.EndTable();
  }
};

struct ExecutionGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LogicNode>>> nodes) {
    fbb_.AddOffset(ExecutionGraph::VT_NODES, nodes);
  }
  void add_links(flatbuffers::Offset<flatbuffers::Vector<const SocketLink *>> links) {
    fbb_.AddOffset(ExecutionGraph::VT_LINKS, links);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeProperty>>> properties) {
    fbb_.AddOffset(ExecutionGraph::VT_PROPERTIES, properties);
  }
  explicit ExecutionGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecutionGraphBuilder &operator=(const ExecutionGraphBuilder &);
  flatbuffers::Offset<ExecutionGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutionGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutionGraph> CreateExecutionGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LogicNode>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SocketLink *>> links = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeProperty>>> properties = 0) {
  ExecutionGraphBuilder builder_(_fbb);
  builder_.add_properties(properties);
  builder_.add_links(links);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecutionGraph> CreateExecutionGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<LogicNode>> *nodes = nullptr,
    const std::vector<SocketLink> *links = nullptr,
    const std::vector<flatbuffers::Offset<NodeProperty>> *properties = nullptr) {
  return executionGraph::serialization::CreateExecutionGraph(
      _fbb,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<LogicNode>>(*nodes) : 0,
      links ? _fbb.CreateVectorOfStructs<SocketLink>(*links) : 0,
      properties ? _fbb.CreateVector<flatbuffers::Offset<NodeProperty>>(*properties) : 0);
}

inline const executionGraph::serialization::ExecutionGraph *GetExecutionGraph(const void *buf) {
  return flatbuffers::GetRoot<executionGraph::serialization::ExecutionGraph>(buf);
}

inline const executionGraph::serialization::ExecutionGraph *GetSizePrefixedExecutionGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<executionGraph::serialization::ExecutionGraph>(buf);
}

inline bool VerifyExecutionGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<executionGraph::serialization::ExecutionGraph>(nullptr);
}

inline bool VerifySizePrefixedExecutionGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<executionGraph::serialization::ExecutionGraph>(nullptr);
}

inline void FinishExecutionGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<executionGraph::serialization::ExecutionGraph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedExecutionGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<executionGraph::serialization::ExecutionGraph> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace serialization
}  // namespace executionGraph

#endif  // FLATBUFFERS_GENERATED_EXECUTIONGRAPH_EXECUTIONGRAPH_SERIALIZATION_H_
